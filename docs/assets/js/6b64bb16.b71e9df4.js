"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5980],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var o=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,o)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,o,n=function(e,t){if(null==e)return{};var a,o,n={},r=Object.keys(e);for(o=0;o<r.length;o++)a=r[o],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)a=r[o],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=o.createContext({}),p=function(e){var t=o.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return o.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(a),m=n,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||r;return a?o.createElement(h,i(i({ref:t},c),{},{components:a})):o.createElement(h,i({ref:t},c))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,i=new Array(r);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,i[1]=l;for(var p=2;p<r;p++)i[p]=a[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,a)}d.displayName="MDXCreateElement"},8031:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var o=a(7462),n=(a(7294),a(3905));const r={},i="SLAM (Simultaneous Localization and Mapping)",l={unversionedId:"ROS2 SDK/How-To/Examples/slam",id:"ROS2 SDK/How-To/Examples/slam",title:"SLAM (Simultaneous Localization and Mapping)",description:"SLAM is a very useful application for autonomous or semi-autonomous robot navigation.",source:"@site/source_files/1_ROS2 SDK/2_How-To/3_Examples/slam.md",sourceDirName:"1_ROS2 SDK/2_How-To/3_Examples",slug:"/ROS2 SDK/How-To/Examples/slam",permalink:"/luci-ros2-sdk-docs/next/ROS2 SDK/How-To/Examples/slam",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"SDK Examples",permalink:"/luci-ros2-sdk-docs/next/ROS2 SDK/How-To/Examples/examples"},next:{title:"luci_basic_teleop",permalink:"/luci-ros2-sdk-docs/next/ROS2 SDK/Packages/Basic Teleop/teleop"}},s={},p=[{value:"Packages",id:"packages",level:2},{value:"Data",id:"data",level:2},{value:"2D vs 3D",id:"2d-vs-3d",level:4},{value:"Ultrasonic Data",id:"ultrasonic-data",level:4},{value:"Odom",id:"odom",level:4},{value:"JS to Twist Message",id:"js-to-twist-message",level:2}],c={toc:p};function u(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,o.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"slam-simultaneous-localization-and-mapping"},"SLAM (Simultaneous Localization and Mapping)"),(0,n.kt)("p",null,"SLAM is a very useful application for autonomous or semi-autonomous robot navigation."),(0,n.kt)("p",null,"LUCI as a sensor platform allows for a jump start on applying a SLAM methodology to power wheelchairs. "),(0,n.kt)("p",null,"While LUCI does not offer a existing SLAM package for the ROS2 SDK we have managed some level of prototype SLAM navigation ourselves. "),(0,n.kt)("p",null,"In doing our own prototyping we have established a few tips for a successful navigation. "),(0,n.kt)("h2",{id:"packages"},"Packages"),(0,n.kt)("p",null,"There are two main SLAM packages that have been tried with LUCI. "),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("a",{parentName:"li",href:"http://wiki.ros.org/slam_toolbox"},"slam_toolbox")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("a",{parentName:"li",href:"http://wiki.ros.org/gmapping"},"gmapping")," ")),(0,n.kt)("p",null,"Both have their pros and cons but were able to be ran with LUCI data streams."),(0,n.kt)("h2",{id:"data"},"Data"),(0,n.kt)("h4",{id:"2d-vs-3d"},"2D vs 3D"),(0,n.kt)("p",null,"While some of the SLAM nodes will expect a 2D point cloud and LUCI provides a 3D cloud you will need some method of converting our provided feed to 2D.\nThis can be done in a couple of ways."),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Implement a z height flatten filter that casts all points to a single z height."),(0,n.kt)("li",{parentName:"ol"},"Run through an existing pointcloud->lidar converter node. This one proved decent.",(0,n.kt)("br",{parentName:"li"}),(0,n.kt)("a",{parentName:"li",href:"https://github.com/ros-perception/pointcloud_to_laserscan"},"pointcloud_to_laserscan"))),(0,n.kt)("b",null,"*Note: Not all SLAM nodes need 2D and 3D data is definitely the better choice to use for LUCI if able*"),(0,n.kt)("p",null,"Casting points to 2D produces a decent map but will struggle with localization later."),(0,n.kt)("h4",{id:"ultrasonic-data"},"Ultrasonic Data"),(0,n.kt)("p",null,"As LUCI produces ultrasonic curves as points it is recommended that you do ",(0,n.kt)("b",null,"NOT")," include them in the mapping of an environment as they will add curved noise to your map."),(0,n.kt)("h4",{id:"odom"},"Odom"),(0,n.kt)("p",null,"Odometry data is critical to the success of SLAM and while it can be found many ways the most common is with IMU and encoders.\nLUCI does offer some Odom data through its onboard IMU but as all chairs that LUCI works with do ",(0,n.kt)("b",null,"NOT")," have wheel position sensors (",(0,n.kt)("em",{parentName:"p"},"they operate on an open loop system"),") LUCI is unable to offer any wheel position at this time."),(0,n.kt)("h2",{id:"js-to-twist-message"},"JS to Twist Message"),(0,n.kt)("p",null,"As LUCI and wheelchairs operate with a left-right/forward-back joystick and SLAM packages expect a ",(0,n.kt)("a",{parentName:"p",href:"http://docs.ros.org/en/melodic/api/geometry_msgs/html/msg/Twist.html"},"Twist")," message a conversion node will be required. "),(0,n.kt)("p",null,"This is unfortunately the nature of a velocity based twist message and a linear JS incompatibility."),(0,n.kt)("p",null,"Here are two different methods LUCI has played with to varying degrees of success that may be of help."),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Find the max speed at a given speed setting then apply a linear fit mapping JS for 0-Max speed in a piece-wise function that is stepped based on speed settings."),(0,n.kt)("li",{parentName:"ol"},"Create a PID loop that takes in a chairs speed (already exposed through the luci_grpc_interface or ideally found from a more accurate source such as external encoders) as well as a goal speed and output a JS value of 0-100. This proved drive-able but does add an extra layer of tuning to your stack. This was ran as a \u201cconverter\u201d node in between the SLAM node and the grpc-endpoint node.")),(0,n.kt)("p",null,"We recommend the PID approach."))}u.isMDXComponent=!0}}]);